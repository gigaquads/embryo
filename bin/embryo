#!/usr/bin/env python3
# encoding=utf8
# vim: set filetype=python

from appyratus.cli import CliProgram, Subparser, Arg
from appyratus.util import DictUtils
from appyratus.io import Yaml

from embryo import Incubator


def main():
    prog = EmbryoProgram(
        name="embryo",
        version="0",
        tagline="wat",
    )
    prog.run()


class EmbryoProgram(CliProgram):
    """
    My very own Embryo Program
    """

    def subparsers(self):
        return [
            HatchSubparser(
                name='hatch',
                usage='Hatch a new embryo',
                defaults=dict(action='hatch'),
                args=[
                    Arg(
                        flags=('embryo', ),
                        dtype=str,
                        usage="Name of the embryo to hatch."
                    ),
                    Arg(
                        flags=('-d', '--destination'),
                        dtype=str,
                        default='.',
                        usage="Destination directory."
                    ),
                    Arg(
                        flags=('-c', '--context'),
                        usage=
                        "Path to a json/yaml context file or an inline JSON object.",
                    )
                ]
            )
        ]


class HatchSubparser(Subparser):
    def perform(self, program):
        incubator = Incubator(
            embryo_name=program.args.embryo,
            destination=program.args.destination,
            context=self.load_context(program.args),
        )
        return incubator.hatch()

    def load_context_arg(self, cli_args_context):
        """
        This loads the --context arg into a dict and returns it.
        """

        def has_ext(filename, extensions):
            return any(
                filename.lower().endswith('.' + ext.lower())
                for ext in extensions
            )

        context = {}

        if cli_args_context:
            context_str = cli_args_context
            if has_ext(context_str, ['json']):
                with open(context_filepath) as context_file:
                    context = ujson.load(context_file)
            elif has_ext(context_str, ['yml', 'yaml']):
                context = Yaml.from_file(context_filepath)
            else:
                # assume it's a JSON object string
                context = ujson.loads(context_str)

        return context

    def load_context(self, cli_args):
        """
        Here, we convert the commandline arguments into a dict and merge it
        together with the dict loaded from the --context argument. The return
        value of this function is the context object passed into the loader.
        """
        non_context_arg_names = {'action', 'context', 'destination', 'embryo'}

        data_from_cli_kwargs = {
            k: getattr(cli_args, k)
            for k in dir(cli_args)
            if not ((k in non_context_arg_names) or k.startswith('_'))
        }

        data_from_context_arg = self.load_context_arg(cli_args.context)

        context = {}
        context.update(data_from_cli_kwargs)
        context.update(data_from_context_arg)
        context = DictUtils.unflatten_keys(context)

        return context


if __name__ == "__main__":
    try:
        main()
    except Exception as error:
        print("ERROR {}".format(error))
        raise error
