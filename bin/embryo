#!/usr/bin/env python3
# encoding=utf8
# vim: set filetype=python

from appyratus.cli import CliProgram, Subparser, PositionalArg, OptionalArg, FlagArg
from appyratus.files import Yaml, Json
from appyratus.utils import DictUtils, TimeUtils
from appyratus.schema import fields

from embryo import Incubator

context = Json.load_file('.embryo/context.json')


def main():
    prog = EmbryoProgram(
        name="embryo",
        version="0",
        tagline="wat",
    )
    prog.run()


class EmbryoProgram(CliProgram):
    """
    My very own Embryo Program
    """

    def subparsers(self):
        return [
            HatchSubparser(
                name='hatch',
                usage='Hatch a new embryo',
                args=[
                    PositionalArg(
                        name='embryo',
                        dtype=str,
                        usage="Name of the embryo to hatch."
                    ),
                    OptionalArg(
                        name='destination',
                        dtype=str,
                        default='.',
                        usage="Destination directory."
                    ),
                    OptionalArg(
                        name='context',
                        usage=
                        "Path to a json/yaml context file or an inline JSON object.",
                    )
                ]
            ),
            HistorySubparser(name='history', usage='')
        ]


class HatchSubparser(Subparser):
    def perform(self, program):
        cli_args = program.cli_args
        self._incubator = Incubator(
            embryo_name=cli_args.embryo,
            destination=cli_args.destination,
            context=self.load_context(cli_args),
        )

        # XXX this is a hacky approach at getting the hatched embryo's context
        # schema as args into embryo.  the reason it is hacky is because the
        # program args have already been built and processed at this point, so
        # they must go through this process again.
        embryo = self._incubator.embryo
        context_fields = embryo.context_schema.fields
        for field_name, field in context_fields.items():
            arg_params = {'name': field.name, 'short_flag': False}
            if isinstance(field, fields.List):
                arg_params['action'] = 'append'
            elif isinstance(field, fields.List):
                arg_params['choices'] = {}
            arg = OptionalArg(**arg_params)
            arg.build(self)
            self._args.append(arg)
        program.cli_args = program.parse_cli_args()
        embryo.context.update(self.load_context(program.cli_args))

        return self._incubator.hatch()

    def load_context_arg(self, cli_args_context):
        """
        This loads the --context arg into a dict and returns it.
        """

        def has_ext(filename, extensions):
            return any(
                filename.lower().endswith('.' + ext.lower())
                for ext in extensions
            )

        context = {}

        if cli_args_context:
            context_str = cli_args_context
            if has_ext(context_str, ['json']):
                with open(context_filepath) as context_file:
                    context = ujson.load(context_file)
            elif has_ext(context_str, ['yml', 'yaml']):
                context = Yaml.from_file(context_filepath)
            else:
                # assume it's a JSON object string
                context = ujson.loads(context_str)

        return context

    def load_context(self, cli_args):
        """
        Here, we convert the commandline arguments into a dict and merge it
        together with the dict loaded from the --context argument. The return
        value of this function is the context object passed into the loader.
        """
        non_context_arg_names = {'action', 'context', 'destination', 'embryo'}

        data_from_cli_kwargs = {
            k: getattr(cli_args, k)
            for k in dir(cli_args)
            if not ((k in non_context_arg_names) or k.startswith('_'))
        }

        data_from_context_arg = self.load_context_arg(cli_args.context)

        context = {}
        context.update(data_from_cli_kwargs)
        context.update(data_from_context_arg)
        context = DictUtils.unflatten_keys(context)

        return context


class HistorySubparser(Subparser):
    def perform(self, program):
        embryo_commands = self.parse_context(context)
        embryo_commands.sort(key=lambda tup: tup[0])
        used_commands = []
        for timestamp, command in embryo_commands:
            if command in used_commands:
                continue
            used_commands.append(command)
            print('{} {}'.format(TimeUtils.from_timestamp(timestamp), command))

    def parse_context(self, context):
        commands = []
        for embryo, contexts in context.items():
            for context in contexts:
                embryo_data = context['embryo']
                del context['embryo']
                flat_context = DictUtils.flatten_keys(context)
                context_args = [
                    '--{} {}'.format(k, v) for k, v in flat_context.items()
                    if v is not None
                ]
                command = 'embryo {} {} {}'.format(
                    embryo_data['action'], embryo, ' '.join(context_args)
                )
                timestamp = embryo_data['timestamp']
                commands.append((timestamp, command))

        return commands


if __name__ == "__main__":
    try:
        main()
    except Exception as error:
        print("ERROR {}".format(error))
        raise error
