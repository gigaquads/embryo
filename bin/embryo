#!/usr/bin/env python3
# encoding=utf8
# vim: set filetype=python

from appyratus.cli import CliProgram, Subparser, PositionalArg, OptionalArg, FlagArg, Parser
from appyratus.files import Yaml, Json
from appyratus.utils import DictUtils, TimeUtils
from appyratus.schema import fields

from embryo import Incubator

context = Json.read('.embryo/context.json')


def main():
    prog = EmbryoProgram(
        name="embryo",
        version="0",
        tagline="wat",
    )
    prog.run()


class EmbryoProgram(CliProgram):
    """
    My very own Embryo Program
    """

    def subparsers(self):
        return [
            HatchSubparser(
                name='hatch',
                usage='Hatch a new embryo',
                args=[
                    PositionalArg(
                        name='embryo',
                        dtype=str,
                        usage="Name of the embryo to hatch.",
                    ),
                    OptionalArg(
                        name='destination',
                        dtype=str,
                        default='.',
                        usage="Destination directory.",
                    ),
                    OptionalArg(
                        name='context',
                        usage="Path to a json/yaml context file or an inline JSON object.",
                    )
                ]
            ),
            HistorySubparser(name='history', usage='View the history of an embryo')
        ]


class HatchSubparser(Subparser):

    @staticmethod
    def perform(program):
        cli_args = program.cli_args
        HatchSubparser.dothis(program, cli_args)

    @staticmethod
    def dothis(program, cli_args):
        cli_args_context = HatchSubparser.load_context(cli_args)
        _incubator = Incubator(
            embryo_name=cli_args.embryo,
            destination=cli_args.destination,
            context=cli_args_context,
        )

        # XXX this is a hacky approach at getting the hatched embryo's context
        # schema as args into embryo.  the reason it is hacky is because the
        # program args have already been built and processed at this point, so
        # they must go through this process again.
        embryo = _incubator.embryo
        context_fields = embryo.context_schema().fields
        nargs = []
        for field_name, field in context_fields.items():
            arg_params = {'name': field.name, 'short_flag': False}
            if isinstance(field, fields.List):
                arg_params['action'] = 'append'
                # XXX where in the field can we store choices to populate this?
                arg_params['choices'] = None
            arg = OptionalArg(**arg_params)
            arg.build(program)
            nargs.append(arg)

        nprogram = CliProgram(args=nargs, cli_args=program._raw_cli_args)
        nprogram.run()
        embryo.context.update(HatchSubparser.load_context(nprogram.cli_args))

        return _incubator.hatch()

    @staticmethod
    def load_context_arg(cli_args_context):
        """
        This loads the --context arg into a dict and returns it.
        """

        def has_ext(filename, extensions):
            return any(filename.lower().endswith('.' + ext.lower()) for ext in extensions)

        context = {}

        if cli_args_context:
            context_str = cli_args_context
            if has_ext(context_str, ['json']):
                context = Json.read(context_filepath)
            elif has_ext(context_str, ['yml', 'yaml']):
                context = Yaml.read(context_filepath)
            else:
                # assume it's a JSON object string
                context = Json.load(context_str)

        return context

    @staticmethod
    def parse_cli_args(cli_args, skip_keys=None):
        if not skip_keys:
            skip_keys = []
        data = {
            k: getattr(cli_args, k)
            for k in dir(cli_args) if not ((k in skip_keys) or k.startswith('_'))
        }
        return data

    @staticmethod
    def load_context(cli_args):
        """
        Here, we convert the commandline arguments into a dict and merge it
        together with the dict loaded from the --context argument. The return
        value of this function is the context object passed into the loader.
        """
        non_context_arg_names = {'context', 'destination', 'embryo'}
        data_from_cli_kwargs = HatchSubparser.parse_cli_args(
            cli_args, non_context_arg_names
        )
        if hasattr(cli_args, 'context'):
            data_from_context_arg = HatchSubparser.load_context_arg(cli_args.context)
        else:
            data_from_context_arg = {}

        context = {}
        context.update(data_from_cli_kwargs)
        context.update(data_from_context_arg)
        context = DictUtils.unflatten_keys(context)

        return context


class HistorySubparser(Subparser):

    @staticmethod
    def perform(program):
        embryo_commands = HisorySubparser.parse_context(context)

        embryo_commands.sort(key=lambda tup: tup[0])
        used_commands = []
        for timestamp, command in embryo_commands:
            if command in used_commands:
                continue
            used_commands.append(command)
            print('{} {}'.format(TimeUtils.from_timestamp(timestamp), command))

    @staticmethod
    def parse_context(context):
        commands = []
        if context is None:
            context = {}
        for embryo, contexts in context.items():
            for context in contexts:
                embryo_data = context['embryo']
                del context['embryo']
                flat_context = DictUtils.flatten_keys(context)
                context_args = [
                    '--{} {}'.format(k, v) for k, v in flat_context.items()
                    if v is not None
                ]
                command = 'embryo {} {} {}'.format(
                    embryo_data['action'], embryo, ' '.join(context_args)
                )
                timestamp = embryo_data['timestamp']
                commands.append((timestamp, command))

        return commands


if __name__ == "__main__":
    try:
        main()
    except Exception as error:
        print("ERROR {}".format(error))
        raise error
